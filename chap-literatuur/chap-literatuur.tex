\chapter{Relevante literatuur}\label{sec:literatuur}
In de literatuur kan men verscheidene methoden om UML-diagrammen te vertalen naar een vari\"eteit aan logica's onderscheiden.

De meeste aandacht gaat naar klassediagrammen. De logica waarnaar vertaald wordt is vaak eerste-orde-predicatenlogica, maar een aantal onderzoekers verkiezen talen die behoren tot de klasse van de \textit{description logics} of relationele logica.

Werken die sequentiediagrammen beschouwen, gebruiken temporele logica's om de vertaling uit te voeren. Mogelijke doelen zijn om de uitvoering van sequentiediagrammen te simuleren, bepalen of een reeks berichten tussen objecten in een softwaresysteem beantwoorden aan het gedrag gespecificeerd in een sequentiediagram, en om te controleren of bepaalde eisen op de functionaliteit van een softwaresysteem waargemaakt worden in een sequentiediagram.

In deze sectie bespreken we een aantal van deze werken.

\section{Redeneren op UML-klassediagrammen gebruikmakend van \textit{description logics}}
Daniela Berardi et al.\cite{BerardiDaniela2005RoUc} tonen eerst een methode om een klassediagram automatisch te vertalen naar eerste-orde logica.

Voor elke klasse definieert men een unair predicaat dat lidmaatschap van die klasse uitdrukt. Vervolgens definieert men voor alle attributen van een klasse een predicaat dat een object van die klasse in verband brengt met een waarde voor dat attribuut. Elke methode krijgt ook een predicaat dat voor combinaties van object waar de methode voor wordt opgeroepen en een stel van parameterwaarden een resultaat definieert. In de uitvoertheorie voegt men dan voorwaarden toe waaraan beantwoord moet worden. Een object heeft zoveel verschillende waardes voor een bepaald attribuut als opgelegd door de multipliciteit voor het attribuut. Voor attribuutwaarden, parameterwaarden en resultaatwaarden wordt afgedwongen dat ze van het juiste type zijn. Een bepaalde combinatie van oproepobject en parameterwaarden moet ook een uniek resultaat hebben bij een oproep.

Associaties krijgen een predicaat dat objecten van de betrokken klasses in verband brengt. De uitvoertheorie dwingt af dat de objecten van het juiste type zijn en dat er gehoorzaamd wordt aan de gespecificeerde multipliciteiten.

Om overerving te modelleren, stelt de uitvoertheorie dat als een object een lid is van een subklasse, dat het dan ook een lid is van de superklasse. Voor een subklasse $C_1$ van superklasse $C$ wordt dit uitgedrukt als $\forall{x}(C_1(x) \Rightarrow C(x))$. Merk op dat deze aanpak niet uitsluit dat een object een lid kan zijn van twee klasses die niet in verband staan met elkaar in een overervingshi\"erarchie, zelfs als de ontwerper dit niet wenst.

De paper stelt een aantal redeneertaken voor die mogelijk zouden moeten zijn voor deze modelleringsmethode. Allereerst is er controle op consistentie van het gehele diagram, wat wil zeggen of er minstens \'e\'en model bestaat van het diagram waarvan de interpretatie voor minstens \'e\'en klasse een object bevat. Verder is er klasseconsistentie, namelijk of voor een klasse een model bestaat waarvoor de interpretatie van die klasse niet leeg is; klassesubsumptie, wat betekent dat het diagram impliceert dat de ene klasse een subklasse is van een andere klasse; klasse\"equivalentie, wat betekent dat het diagram oplegt dat voor twee klasses de interpretatie gelijk is in alle modellen en dat \'e\'en van die klasses dus verwijderd kan worden uit het diagram; en het detecteren van eigenschappen van klasses en associaties die ervoor zorgen dat bepaalde gespecificeerde multipliciteiten en typering in het diagram eigenlijk strenger zijn dan expliciet neergeschreven in het diagram.

De rest van de paper handelt over \textit{description logics}. Men geeft een beschrijving van een aantal talen die behoren tot de \textit{description logics} en beschrijft hoe men een klassediagram kan vertalen naar $\mathcal{ALCQI}$\cite{LutzCarsten2005Tcof}, wat zulk een \textit{description logic} is. Verder geeft men een gevalstudie van software die zulk een vertaling kan uitvoeren en kan antwoorden op queries zoals of een object van een bepaalde klasse exact \'e\'enmaal deelneemt aan een bepaalde associatie zonder dat het diagram dit expliciet oplegt. De auteurs concluderen dat dit soort redeneertaak behoort tot de klasse van EXPTIME-harde problemen.

De methode om klassediagrammen te vertalen naar eerste-orde-predicatenlogica voorgesteld in deze paper dient als de basis voor onze eigen methode gepresenteerd in hoofdstuk \ref{sec:consistentie}. We passen deze methode aan om gebruik te maken van concepten aangeboden door FO($\cdot$)\cite{DeCatBroes2014PLaa}.

\section{Het modelleren van klassediagrammen en OCL-constraints in relationele logica}
Mirco Kuhlmann et al.\cite{KuhlmannMirco2012FUaO} geven een inleiding tot relationele logica en de semantiek ervan. Men beschrijft hoe een instantie van een model van relationele logica wordt opgebouwd door relaties die atomen of tupels van atomen bevatten en welke operaties op relaties beschikbaar zijn. Relationele logica biedt bewerkingen zoals \textit{joins}, cartesisch product en transitieve sluiting aan. Verder kan men ook gebruikmaken van verzamelingscomprehensie, bewerkingen op verzamelingen zoals unie en deelverzameling, booleaanse operatoren zoals conjunctie en implicatie, universele en existenti\"ele kwantoren en bewerkingen op gehele getallen. In de paper vertaalt men klassediagrammen en beperkingen uitgedrukt in OCL-voorwaarden\cite{WarmerJosB1999Ocl:} op zulk een manier dat er rechtstreeks gebruik wordt gemaakt van de structuur aangeboden door relationele logica. Op die manier bekomt men modellen die op een effici\"ente manier verwerkt kunnen worden ten koste van significante beperkingen op diagrammen en OCL-voorwaarden die kunnen dienen als invoer.

Men schetst hoe primitieve types voorgesteld worden door unaire relaties van atomen. In relationele logica worden objecten voorgesteld door constanten, en deze constanten worden gebruikt als atomen in binaire relaties die objecten verbinden met waarden voor klasseattributen. Eveneens brengt men objecten in verband met elkaar in relaties die associaties voorstellen. Er worden voorwaarden gelegd op relaties die attributen en associaties voorstellen zodanig dat de gebruikte objecten van het juiste type zijn en dat de multipliciteiten gespecificeerd in het diagram afgedwongen worden. Aangezien men relaties op zulk een eenvoudige wijze gebruikt, is het eenvoudig om een stel van relaties en type- en multipliciteitsvoorwaarden te vertalen naar een klassediagram.

Men beschrijft hoe uitdrukkingen in OCL vertaald kunnen worden naar relationele logica. Bewerkingen op booleaanse waarden, gehele getallen, het allesomvattende type OclAny\cite{WarmerJosB1999Ocl:}, bewerkingen op verzamelingen met \textit{collect} in het bijzonder en navigatie van associaties worden ondersteund.

De auteurs gebruiken Kodkod\cite{10.1007/978-3-540-71209-1_49} om geldige instanties van een relationeel model te berekenen. Kodkod vertaalt relationele modellen naar SAT-formules en vertaalt oplossingen naar instanties van dat relationeel model.

\section{Simulatie en verificatie van sequentiediagrammen met lineaire temporele logica}

V. Lima et al.\cite{LIMA2009143} beschrijven hoe sequentiediagrammen vertaald kunnen worden naar een specificatie in PROMELA\cite{neumann2014using}. PROMELA is een taal die processen modelleert. De \textit{model checker} SPIN\cite{holzmann2004spin} gebruikt specificaties opgesteld in PROMELA om te verifi\"eren of bepaalde eigenschappen geformuleerd in lineaire temporele logica (LTL) gelden voor de voorgestelde processen. LTL is een modale logica die operatoren aanbiedt die verwijzen naar tijd. Tijd bestaat uit een reeks toestanden. Elke toestand specificeert voor alle beschouwde propositionele variabelen in een domein of ze waar of niet waar zijn in die toestand.

De paper beschrijft hoe basiselementen van sequentiediagrammen, zoals levenslijnen en berichten, voor te stellen in PROMELA. Dit gebeurt ook voor verscheidene soorten van gecombineerde fragmenten, zoals het altfragment, het lusfragment, het optioneel fragment, het parallel fragment en het \textit{break}-fragment. Zo is het mogelijk om de uitvoering van een sequentiediagram te simuleren.

De paper beschrijft ook hoe de toestand van een uitvoering van een sequentiediagram voor te stellen. Een toestand bestaat uit vier delen: De meest recent uitgevoerde actie; de levenslijn die die actie uitvoert; het bericht betrokken in de actie; en de levenslijn die het bericht stuurt/ontvangt.

Verder beschrijven de auteurs hoe men mogelijke eigenschappen van een systeem kan uitdrukken in LTL-formules. Deze formules gebruiken toestanden van de uitvoering van een sequentiediagram. Ter voorbeeld geven ze een sequentiediagram dat de werking van een geldautomaat modelleert. Ze stellen LTL-formules op om vier gewenste eigenschappen uit te drukken en gebruiken SPIN om te verifi\"eren of deze eigenschappen gelden in het sequentiediagram. Het besluit is dat maar \'e\'en eigenschap geldt. SPIN vindt voor de andere drie eigenschappen tegenvoorbeelden van mogelijke uitvoeringen van het sequentiediagram die de eigenschap schenden. De verificatie voor elk van de eigenschappen duurde hoogstens een kwartseconde, met een maximaal geheugengebruik van 3,673 MB.

De auteurs beschouwen echter sequentiediagrammen onafhankelijk van enig bijhorend klassediagram. Er is geen notie van klassevariabelen voor de objecten die met elkaar communiceren in een klassediagram. De voorstelling gegeven in deze paper beschrijft dus niet hoe de toestand van een object verandert terwijl een sequentiediagram wordt uitgevoerd. Verder beschouwen de auteurs ook geen sequentiediagrammen die methodes gemodelleerd in een ander sequentiediagram oproepen. Men krijgt enkel inzicht in het gedrag van het systeem als geheel door te kijken hoe de uitvoering van het systeem verloopt over verschillende sequentiediagrammen heen.

\section{Conclusie}

\sloppy We merken dat de literatuur zich voornamelijk toelegt op het vertalen van UML-klassediagrammen naar talen die minder expressief zijn dan eerste-orde-predicatenlogica. Men ruilt expressiviteit in voor kortere rekentijd en kleiner ruimtegebruik. We denken echter aan het modelleren van overerving: het bepalen van tot welke klasses een object behoort ten gevolge van de gespecificeerde klassehi\"erarchie\"en is een voorbeeld van het berekenen van een transitieve sluiting, wat niet uit te drukken is in eerste-orde-predicatenlogica en dus ook niet in deze minder expressieve talen.

Verder is er al werk geleverd omtrent het simuleren en verifi\"eren van sequentiediagrammen. Het perspectief blijft echter beperkt tot \'e\'en sequentiediagram tegelijkertijd. Het ontbreekt dus aan een methode om te verifi\"eren of het gedrag van een systeem dat wordt gemodelleerd in meerdere sequentiediagrammen als geheel beantwoordt aan bepaalde functionele eisen.